# Рубежный контроль.
## Вопрос 5:
 * Токены. Рассказать какие виды токенов бывают и для чего могут применяться. 
 * Закодировать с помощью одного из способов (как то предполагает выбранный вами стандарт) следующую информацию: имя пользователя, айди пользователя, айди устройства пользователя, выданные роли, дату окончания действия токена, алгоритм шифрования, того кто выдал токен и для кого он предназначен (т.е. продемонстрировать и пояснить как эта информация будет содержаться в токене и как её извлечь).

## Ответ:

### ***Аутентификация по токенам***

Такой способ аутентификации чаще всего применяется при построении распределенных систем Single Sign-On (SSO), где одно приложение (service provider или relying party) делегирует функцию аутентификации пользователей другому приложению (identity provider или authentication service). Типичный пример этого способа — вход в приложение через учетную запись в социальных сетях. Здесь социальные сети являются сервисами аутентификации, а приложение доверяет функцию аутентификации пользователей социальным сетям.

Реализация этого способа заключается в том, что identity provider (IP) предоставляет достоверные сведения о пользователе в виде токена, а service provider (SP) приложение использует этот токен для идентификации, аутентификации и авторизации пользователя.
На общем уровне, весь процесс выглядит следующим образом:

Клиент аутентифицируется в identity provider одним из способов, специфичным для него (пароль, ключ доступа, сертификат, Kerberos, итд.).
Клиент просит identity provider предоставить ему токен для конкретного SP-приложения. Identity provider генерирует токен и отправляет его клиенту.
Клиент аутентифицируется в SP-приложении при помощи этого токена.

*Пример аутентификации «активного» клиента при помощи токена, переданного посредством:*

![b190b11c0d934c999c1955184ddeb0c3](https://user-images.githubusercontent.com/58026852/123509583-fa63cd00-d67e-11eb-992a-7091e241493d.png "Пример аутентификации «активного» клиента при помощи токена, переданного посредством") 

Процесс, описанный выше, отражает механизм аутентификации активного клиента, т. е. такого, который может выполнять запрограммированную последовательность действий (например, iOS/Android приложения). Браузер же — пассивный клиент в том смысле, что он только может отображать страницы, запрошенные пользователем. В этом случае аутентификация достигается посредством автоматического перенаправления браузера между веб-приложениями identity provider и service provider.

*Пример аутентификации «пассивного» клиента посредством перенаправления запросов:*

![image](https://user-images.githubusercontent.com/58026852/123509735-e8365e80-d67f-11eb-9962-7fce490c68c1.png "Пример аутентификации «пассивного» клиента посредством перенаправления запросов.")

Существует несколько стандартов, в точности определяющих протокол взаимодействия между клиентами (активными и пассивными) и IP/SP-приложениями и формат поддерживаемых токенов. Среди наиболее популярных стандартов — OAuth, OpenID Connect, SAML, и WS-Federation.

#### ***Токен***

Сам токен обычно представляет собой структуру данных, которая содержит информацию, кто сгенерировал токен, кто может быть получателем токена, срок действия, набор сведений о самом пользователе (claims). Кроме того, токен дополнительно подписывается для предотвращения несанкционированных изменений и гарантий подлинности.

При аутентификации с помощью токена SP-приложение должно выполнить следующие проверки:

1. Токен был выдан доверенным identity provider приложением (проверка поля issuer).
2. Токен предназначается текущему SP-приложению (проверка поля audience).
3. Срок действия токена еще не истек (проверка поля expiration date).
4. Токен подлинный и не был изменен (проверка подписи).

*В случае успешной проверки SP-приложение выполняет авторизацию запроса на основании данных о пользователе, содержащихся в токене.*

### Форматы токенов

*Существует несколько распространенных форматов токенов для веб-приложений:*

1. **Simple Web Token (SWT)** — наиболее простой формат, представляющий собой набор произвольных пар имя/значение в формате кодирования HTML form. Стандарт определяет несколько зарезервированных имен: Issuer, Audience, ExpiresOn и HMACSHA256. Токен подписывается с помощью симметричного ключа, таким образом оба IP- и SP-приложения должны иметь этот ключ для возможности создания/проверки токена.

*Пример SWT токена (после декодирования):*

```
Issuer=http://auth.myservice.com&
Audience=http://myservice.com& 
ExpiresOn=1435937883& 
UserName=John Smith& 
UserRole=Admin& 
HMACSHA256=KOUQRPSpy64rvT2KnYyQKtFFXUIggnesSpE7ADA4o9w

```

2. ***JSON Web Token (JWT)*** — содержит три блока, разделенных точками: заголовок, набор полей (claims) и подпись. Первые два блока представлены в JSON-формате и дополнительно закодированы в формат base64. Набор полей содержит произвольные пары имя/значения, притом стандарт JWT определяет несколько зарезервированных имен (iss, aud, exp и другие). Подпись может генерироваться при помощи и симметричных алгоритмов шифрования, и асимметричных. Кроме того, существует отдельный стандарт, отписывающий формат зашифрованного JWT-токена.

*Пример подписанного JWT токена (после декодирования 1 и 2 блоков).*
```
{ «alg»: «HS256», «typ»: «JWT» }.
{ «iss»: «auth.myservice.com», «aud»: «myservice.com», «exp»: «1435937883», «userName»: «John Smith», «userRole»: «Admin» }.
S9Zs/8/uEGGTVVtLggFTizCsMtwOJnRhjaQ2BMUQhcY
```
3. ***Security Assertion Markup Language (SAML)*** — определяет токены (SAML assertions) в XML-формате, включающем информацию об эмитенте, о субъекте, необходимые условия для проверки токена, набор дополнительных утверждений (statements) о пользователе. Подпись SAML-токенов осуществляется при помощи ассиметричной криптографии. Кроме того, в отличие от предыдущих форматов, SAML-токены содержат механизм для подтверждения владения токеном, что позволяет предотвратить перехват токенов через man-in-the-middle-атаки при использовании незащищенных соединений.

*Пример SAML:*

```
<saml:Assertion
   xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion"
   xmlns:xs="http://www.w3.org/2001/XMLSchema"
   ID="_d71a3a8e9fcc45c9e9d248ef7049393fc8f04e5f75"
   Version="2.0"
   IssueInstant="2004-12-05T09:22:05Z">
   <saml:Issuer>https://idp.example.org/SAML2</saml:Issuer>
   <ds:Signature
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#">...</ds:Signature>
   <saml:Subject>
     <saml:NameID
       Format="urn:oasis:names:tc:SAML:2.0:nameid-format:transient">
       3f7b3dcf-1674-4ecd-92c8-1544f346baf8
     </saml:NameID>
     <saml:SubjectConfirmation
       Method="urn:oasis:names:tc:SAML:2.0:cm:bearer">
       <saml:SubjectConfirmationData
         InResponseTo="aaf23196-1773-2113-474a-fe114412ab72"
         Recipient="https://sp.example.com/SAML2/SSO/POST"
         NotOnOrAfter="2004-12-05T09:27:05Z"/>
     </saml:SubjectConfirmation>
   </saml:Subject>
   <saml:Conditions
     NotBefore="2004-12-05T09:17:05Z"
     NotOnOrAfter="2004-12-05T09:27:05Z">
     <saml:AudienceRestriction>
       <saml:Audience>https://sp.example.com/SAML2</saml:Audience>
     </saml:AudienceRestriction>
   </saml:Conditions>
   <saml:AuthnStatement
     AuthnInstant="2004-12-05T09:22:00Z"
     SessionIndex="b07b804c-7c29-ea16-7300-4f3d6f7928ac">
     <saml:AuthnContext>
       <saml:AuthnContextClassRef>
         urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport
       </saml:AuthnContextClassRef>
     </saml:AuthnContext>
   </saml:AuthnStatement>
   <saml:AttributeStatement>
     <saml:Attribute
       xmlns:x500="urn:oasis:names:tc:SAML:2.0:profiles:attribute:X500"
       x500:Encoding="LDAP"
       NameFormat="urn:oasis:names:tc:SAML:2.0:attrname-format:uri"
       Name="urn:oid:1.3.6.1.4.1.5923.1.1.1.1"
       FriendlyName="eduPersonAffiliation">
       <saml:AttributeValue
         xsi:type="xs:string">member</saml:AttributeValue>
       <saml:AttributeValue
         xsi:type="xs:string">staff</saml:AttributeValue>
     </saml:Attribute>
   </saml:AttributeStatement>
 </saml:Assertion>
 ```
 ### ***Закодировать с помощью jwt  информацию:***
 
 *Схема работы очень простая (в теории, по крайней мере):*

1. Сначала пользователь проходит привычную аутентификацию. Это может быть пара логин-пароль или вход через какую-нибудь соцсеть.
2. Если все прошло удачно, сервер аутентификации создает JWT и отправляет его пользователю обратно. 
3. Теперь пользователь пытается взаимодействовать с приложением через API. Делая запрос, он передает также полученный токен.
4. Сервер приложения проверяет, действительно ли этот токен был выдан сервером аутентификации.
5. Если JWT подлинный, сервер просто выполняет полученный запрос и пользователь получает нужный ему результат.

В сериализованном виде JWT выглядит примерно так:

[ base64UrlEncode(header) ] . [ base64UrlEncode(payload) ] . [signature ]
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.XbPfbIHMI6arZ3Y922BhjWgQzWXcXNrz0ogtVhfEd2o 
```
Заголовок и полезная нагрузка кодируются при помощи алгоритма base64url, после чего объединяются в единую строку с использованием точки (".") в качестве разделителя.

Генерируется подпись (в моем примере — с применением алгоритма HMAC-SHA256), которая добавляется к исходной строке так же через точку.

Если вы раскодируете этот base64, то получите JSON в виде 3 важных частей: заголовка, информационного наполнения и подписи.

#### *Шаг 1. Заголовок*

В заголовке JWT содержатся технические данные – название алгоритма, используемого для генерации подписи токена. Выглядит он вот так:
```
{
  "typ": "JWT",
  "alg": "HS256"
}
```
Поле typ содержит тип токена (для JSON веб-токенов соответственно оно всегда равно JWT).

Значение поля alg соответствует алгоритму хеширования HMAC-SHA256, который использует секретный ключ для вычисления подписи. Здесь может быть указан другой алгоритм или даже none, если токен не подписан.

#### *Шаг 2. Полезная нагрузка*

Во втором компоненте JSON веб-токенов (payload) хранится информация о пользователе, которую сервер аутентификации передает серверу приложения. Стандарт предусматривает несколько необязательных для заполнения служебных полей, например:

* **iss**: чувствительная к регистру строка или URI, которая является уникальным идентификатором стороны, генерирующей токен (issuer).

* **sub**: чувствительная к регистру строка или URI, которая является уникальным идентификатором стороны, о которой содержится информация в данном токене (subject). Значения с этим ключом должны быть уникальны в контексте стороны, генерирующей JWT.

* **aud**: массив чувствительных к регистру строк или URI, являющийся списком получателей данного токена. Когда принимающая сторона получает JWT с данным ключом, она должна проверить наличие себя в получателях — иначе проигнорировать токен (audience).

* **exp**: время в формате Unix Time, определяющее момент, когда токен станет невалидным (expiration).

* **nbf**: в противоположность ключу exp, это время в формате Unix Time, определяющее момент, когда токен станет валидным (not before).

* **jti**: строка, определяющая уникальный идентификатор данного токена (JWT ID).

* **iat**: время в формате Unix Time, определяющее момент, когда токен был создан. iat и nbf могут не совпадать, например, если токен был создан раньше, чем время, когда он должен стать валидным.

Помимо стандартных ключей, можно передавать любые необходимые данные, а именно в нашем случае(имя пользователя, айди пользователя, айди устройства пользователя, выданные роли, дату окончания действия токена, алгоритм шифрования, того кто выдал токен и для кого он предназначен):

userName — имя пользователя;
userid — уникальный идентификатор пользователя;
deviceid - айди устройства пользователя;
roles — роль пользователя, например admin, user, guest;
exp - дату окончания действия токена;

```
{
  "userName": "Polina", 
  "userId": "b08f86af-35da-48f2-8fab-cef3904660bd",
  "deviceId": " 0156",
  "roles": "admin",
  "exp":"1570019636365",
  "sub": 
}
```
#### *Шаг 3. Подпись*
Подпись токена вычисляется на основе его заголовка и полезной нагрузки по следующей схеме:

```
const SECRET_KEY = 'cAtwa1kkEy'
const unsignedToken = base64urlEncode(header) + '.' + base64urlEncode(payload)
const signature = HMAC-SHA256(unsignedToken, SECRET_KEY)
```
* Заголовок и полезная нагрузка по отдельность кодируются с помощью алгоритма Base64URL, а затем соединяются через точку. 
```
// header
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9

// payload
eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ
```
* Эта строка затем хешируется с использованием секретного ключа (secret).
```
// signature
-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM

```
* Хешированные данные снова пропускаются через Base64URL – это и есть подпись JWT.
Получив JWT от пользователя, приложение самостоятельно вычислит значение подписи и сравнит его с тем значением, которое было передано в токене. Если эти значения не совпадут, значит, токен был модифицирован или сгенерирован недоверенной стороной, и принимать такой токен и доверять ему приложение не будет.

Шаг 4. Cборка JWT
У нас уже есть все необходимые блоки для создания токена:

* заголовок с указанием алгоритма хеширования;
* полезная нагрузка с пользовательскими данными;
* сгенерированная подпись.

Теперь можно собрать из них полноценный веб-токен по уже знакомой схеме:
```
header.payload.signature
```
Заголовок и полезная нагрузка предварительно кодируются в Base64URL, а подпись уже в правильном формате:

```
// JWT
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1nij9.eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhltq4zjitogzhyi1jzwyzota0njywymqifq.-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM
```

Этот токен пользователь получит от сервера аутентификации и будет использовать при запросах к серверу приложения.
